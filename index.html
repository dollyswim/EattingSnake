<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>å¯æ„›ç²‰ç´…è²ªé£Ÿè›‡ ğŸğŸŒ¸</title>
  <style>
    :root{
      /* ç²‰è‰²ç³»é…è‰²è®Šæ•¸ */
      --bg-start: #fff9fb;
      --bg-end: #ffe3ec;
      --panel: #ffffffdd;
      --text: #704848;       /* æº«æš–çš„å¯å¯æ£•è‰² */
      --muted: #a88888;
      --border: #ffc2d1;     /* å«©ç²‰è‰²é‚Šæ¡† */
      --shadow: 0 10px 25px rgba(219, 112, 147, 0.15); /* ç²‰è‰²èª¿çš„é™°å½± */
    }
    *{ box-sizing: border-box; }
    body{
      margin:0;
      /* æ”¾å°„ç‹€ç²‰è‰²æ¼¸å±¤èƒŒæ™¯ */
      background: radial-gradient(circle at 50% 30%, var(--bg-start), var(--bg-end));
      font-family: ui-rounded, system-ui, "Microsoft JhengHei", sans-serif;
      color:var(--text);
      display:flex;
      flex-direction: column;
      align-items:center;
      justify-content:center;
      min-height: 100vh;
      padding: 10px;
      touch-action: none;
      overflow: hidden;
    }
    .wrap{
      width: 100%;
      max-width: 800px;
      display:grid;
      grid-template-columns: 1fr;
      gap:12px;
    }
    .topbar{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
      padding:10px 16px;
      background:var(--panel);
      border:2px solid var(--border);
      border-radius:24px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(8px);
    }
    .title h1{
      margin:0;
      font-size: clamp(16px, 4vw, 20px);
      letter-spacing: 1px;
      color: #db7093; /* ç´«ç¾…è˜­ç´… */
    }
    .stats{
      display:flex;
      gap:8px;
    }
    .pill{
      padding:6px 12px;
      border-radius:99px;
      background:#fff;
      border:2px solid #ffeef2;
      font-size:13px;
      font-weight: bold;
      color: var(--text);
      white-space: nowrap;
      box-shadow: 0 2px 8px rgba(0,0,0,.03);
    }
    canvas{
      width:100%;
      background: #fffbfd; /* æ¥µæ·¡çš„ç²‰ç™½ç•«å¸ƒèƒŒæ™¯ */
      border-radius:20px;
      border:4px solid #ffdeeb; /* ç•«å¸ƒé‚Šæ¡† */
      box-shadow: var(--shadow);
      display:block;
      touch-action: none;
    }
    .footer{
      padding:12px;
      background: rgba(255, 255, 255, 0.6);
      border-radius:16px;
      color: var(--muted);
      font-size:12px;
      text-align: center;
      border: 1px solid #fff0f5;
    }
    .badge{
      font-size:11px;
      padding:2px 8px;
      border-radius:10px;
      background:#ffeff5;
      color:#db7093;
      border: 1px solid #ffc2d1;
      margin-left: 6px;
      vertical-align: middle;
    }
    @media (max-width: 600px) {
      .desktop-hint { display: none; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <div class="title">
        <h1>è²ªé£Ÿè›‡<span class="badge">Pink Ver.</span></h1>
      </div>
      <div class="stats">
        <div class="pill">ğŸ† <span id="highScore">0</span></div>
        <div class="pill">ğŸŒ¸ <span id="score">0</span></div>
      </div>
    </div>

    <canvas id="game"></canvas>

    <div class="footer">
      <span class="desktop-hint">éµç›¤ â†‘â†“â†â†’ æ§åˆ¶ï¼Œç©ºç™½éµæš«åœï½œ</span>
      <span>ğŸ æ°´æœ+1  ğŸ© é»å¿ƒ+3</span>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");
  const scoreEl = document.getElementById("score");
  const highScoreEl = document.getElementById("highScore");

  // Utilities
  const clamp = (n, a, b) => Math.max(a, Math.min(b, n));
  const keyOf = (x, y) => `${x},${y}`;

  function loadHighScore() {
    try { return Number(localStorage.getItem("pink_snake_highscore") || 0) || 0; } catch { return 0; }
  }
  function saveHighScore(v) {
    try { localStorage.setItem("pink_snake_highscore", String(v)); } catch {}
  }

  // ===== è³‡æ–™è¨­å®š =====
  const FRUITS = [
    { name:"è‰è“", emoji:"ğŸ“", points:1 },
    { name:"æ«»æ¡ƒ", emoji:"ğŸ’", points:1 },
    { name:"æ°´èœœæ¡ƒ", emoji:"ğŸ‘", points:1 },
    { name:"è˜‹æœ", emoji:"ğŸ", points:1 },
    { name:"è‘¡è„", emoji:"ğŸ‡", points:1 }
  ];
  const SNACKS = [
    { name:"ç³°å­", emoji:"ğŸ¡", points:3 },
    { name:"ç³–æœ", emoji:"ğŸ¬", points:3 },
    { name:"è›‹ç³•", emoji:"ğŸ°", points:3 },
    { name:"å†°æ·‡æ·‹", emoji:"ğŸ¦", points:3 },
    { name:"ç”œç”œåœˆ", emoji:"ğŸ©", points:3 },
  ];

  class FoodManager {
    constructor(game) {
      this.game = game;
      this.current = null;
      this.spawnAt = 0;
    }
    randomFood() {
      // 35% æ©Ÿç‡æ˜¯ç”œé»
      const isSnack = Math.random() < 0.35;
      const pool = isSnack ? SNACKS : FRUITS;
      return pool[Math.floor(Math.random() * pool.length)];
    }
    spawn(occupiedSet, now) {
      const { cols, rows } = this.game;
      let tries = 0;
      while (tries < 200) {
        const x = Math.floor(Math.random() * cols);
        const y = Math.floor(Math.random() * rows);
        if (!occupiedSet.has(keyOf(x,y))) {
          const f = this.randomFood();
          this.current = { ...f, pos:{x,y} };
          this.spawnAt = now;
          return this.current;
        }
        tries++;
      }
      return null;
    }
    popScale(now) {
      // é£Ÿç‰©å½ˆè·³å‹•ç•«
      const t = clamp((now - this.spawnAt) / 300, 0, 1);
      const s = 1 + Math.sin(t * Math.PI * 1.5) * 0.25;
      return t < 1 ? s : 1; 
    }
  }

  // ===== ç‰¹æ•ˆèˆ‡ç²’å­ =====
  class EffectSystem {
    constructor() { this.items = []; }
    emitSparkle(x, y) {
      const count = 5;
      for(let i=0; i<count; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 50 + 30;
        this.items.push({
          type: 'sparkle', x, y,
          vx: Math.cos(angle)*speed, vy: Math.sin(angle)*speed,
          life: 1.0, size: Math.random()*6 + 2,
          color: Math.random() > 0.5 ? '#FFB6C1' : '#FF69B4' // æ·ºç²‰èˆ‡ç†±ç²‰è‰²ç²’å­
        });
      }
    }
    emitText(x, y, text) {
      this.items.push({
        type: 'text', x, y, text,
        vy: -40, life: 1.0
      });
    }
    update(dt) {
      for(let p of this.items) {
        p.life -= dt * 1.2;
        p.x += (p.vx || 0) * dt;
        p.y += (p.vy || 0) * dt;
        if(p.type === 'text') p.vy *= 0.95; 
      }
      this.items = this.items.filter(p => p.life > 0);
    }
    draw(ctx) {
      for(let p of this.items) {
        ctx.globalAlpha = clamp(p.life, 0, 1);
        if(p.type === 'sparkle') {
          ctx.fillStyle = p.color;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
          ctx.fill();
        } else if (p.type === 'text') {
          ctx.font = "bold 15px sans-serif";
          ctx.fillStyle = "#db7093";
          ctx.fillText(p.text, p.x, p.y);
        }
      }
      ctx.globalAlpha = 1;
    }
  }

  // ===== è›‡çš„é‚è¼¯ =====
  class Snake {
    constructor(gx, gy) {
      this.body = [{x:gx, y:gy}, {x:gx-1, y:gy}, {x:gx-2, y:gy}];
      this.dir = {x:1, y:0};
      this.inputQueue = [];
      this.growPending = 0;
    }
    queueDirection(dx, dy) {
      const lastDir = this.inputQueue.length > 0 ? this.inputQueue[this.inputQueue.length-1] : this.dir;
      if (dx === -lastDir.x && dy === -lastDir.y) return;
      if (dx === lastDir.x && dy === lastDir.y) return;
      if (this.inputQueue.length < 2) this.inputQueue.push({x:dx, y:dy});
    }
    update() {
      if (this.inputQueue.length > 0) this.dir = this.inputQueue.shift();
      const head = this.body[0];
      const next = { x: head.x + this.dir.x, y: head.y + this.dir.y };
      this.body.unshift(next);
      if (this.growPending > 0) this.growPending--;
      else this.body.pop();
      return next;
    }
    hitsSelf() {
      const head = this.body[0];
      for (let i=1; i<this.body.length; i++) {
        if (this.body[i].x === head.x && this.body[i].y === head.y) return true;
      }
      return false;
    }
  }

  // ===== éŠæˆ²ä¸»æ§ =====
  class Game {
    constructor() {
      this.resize();
      window.addEventListener('resize', () => this.resize());
      
      this.effects = new EffectSystem();
      this.highScore = loadHighScore();
      highScoreEl.textContent = this.highScore;
      
      this.blinkTimer = 0;
      this.isBlinking = false;

      this.reset();
      this.bindControls();
      
      this.lastTime = performance.now();
      requestAnimationFrame(this.loop.bind(this));
    }

    resize() {
      const isMobile = window.innerWidth < 600;
      this.gridSize = isMobile ? 26 : 22; // æ ¼å­å¤§å°
      
      const maxWidth = 800;
      const w = Math.min(window.innerWidth - 24, maxWidth);
      const h = isMobile ? window.innerHeight * 0.55 : 480;

      canvas.width = w;
      canvas.height = h;

      this.cols = Math.floor(w / this.gridSize);
      this.rows = Math.floor(h / this.gridSize);
    }

    reset() {
      this.state = "start";
      this.score = 0;
      this.tickRate = 140; 
      this.tickAcc = 0;
      
      this.snake = new Snake(Math.floor(this.cols/2), Math.floor(this.rows/2));
      
      this.food = new FoodManager(this);
      this.food.spawn(new Set(this.snake.body.map(p=>keyOf(p.x,p.y))), performance.now());
      
      scoreEl.textContent = 0;
      this.renderBody = [];
    }

    bindControls() {
      window.addEventListener("keydown", e => {
        if (e.key === " ") {
            if(this.state === "gameover") this.reset();
            else this.state = (this.state === "running") ? "paused" : "running";
            e.preventDefault();
        }
        if (["ArrowUp","w","W"].includes(e.key)) this.handleInput(0, -1);
        if (["ArrowDown","s","S"].includes(e.key)) this.handleInput(0, 1);
        if (["ArrowLeft","a","A"].includes(e.key)) this.handleInput(-1, 0);
        if (["ArrowRight","d","D"].includes(e.key)) this.handleInput(1, 0);
        if (e.key.toLowerCase() === "r") this.reset();
      });

      let tsX, tsY;
      canvas.addEventListener('touchstart', e => {
        e.preventDefault();
        tsX = e.touches[0].clientX;
        tsY = e.touches[0].clientY;
        if (this.state !== "running" && this.state !== "paused") {
             if(this.state === "gameover") this.reset();
             else this.state = "running";
        }
      }, {passive: false});

      canvas.addEventListener('touchmove', e => {
        e.preventDefault(); 
        if (!tsX || !tsY) return;
        const dx = e.touches[0].clientX - tsX;
        const dy = e.touches[0].clientY - tsY;
        if (Math.abs(dx) > 10 || Math.abs(dy) > 10) {
          if (Math.abs(dx) > Math.abs(dy)) {
            this.handleInput(dx > 0 ? 1 : -1, 0);
          } else {
            this.handleInput(0, dy > 0 ? 1 : -1);
          }
          tsX = e.touches[0].clientX;
          tsY = e.touches[0].clientY;
        }
      }, {passive: false});
    }

    handleInput(dx, dy) {
      if (this.state === "start") this.state = "running";
      if (this.state !== "running") return;
      this.snake.queueDirection(dx, dy);
    }

    tick(now) {
        if (this.state !== "running") return;
        const head = this.snake.update();

        if (head.x < 0 || head.x >= this.cols || head.y < 0 || head.y >= this.rows || this.snake.hitsSelf()) {
            this.gameOver(); return;
        }

        const f = this.food.current;
        if (f && head.x === f.pos.x && head.y === f.pos.y) {
            this.score += f.points;
            scoreEl.textContent = this.score;
            if (this.score > this.highScore) {
                this.highScore = this.score;
                highScoreEl.textContent = this.score;
                saveHighScore(this.score);
            }
            this.tickRate = Math.max(90, this.tickRate - 1.5);
            this.snake.growPending++;

            const fx = head.x * this.gridSize + this.gridSize/2;
            const fy = head.y * this.gridSize + this.gridSize/2;
            this.effects.emitText(fx, fy - 10, `+${f.points}`);
            this.effects.emitSparkle(fx, fy); // åƒåˆ°ä»»ä½•æ±è¥¿éƒ½å™´ç²’å­

            const occ = new Set(this.snake.body.map(p=>keyOf(p.x,p.y)));
            if (!this.food.spawn(occ, now)) this.state = "gameover";
        }
    }

    gameOver() {
        this.state = "gameover";
        if(navigator.vibrate) navigator.vibrate(200);
    }

    loop(ts) {
      const dt = Math.min((ts - this.lastTime) / 1000, 0.1);
      this.lastTime = ts;

      this.effects.update(dt);

      this.blinkTimer -= dt;
      if (this.blinkTimer <= 0) {
        this.isBlinking = !this.isBlinking;
        this.blinkTimer = this.isBlinking ? 0.15 : (Math.random() * 3 + 2);
      }

      if (this.state === "running") {
        this.tickAcc += dt * 1000;
        while (this.tickAcc >= this.tickRate) {
          this.tick(ts);
          this.tickAcc -= this.tickRate;
          if(this.state !== "running") break;
        }
      }

      this.draw(dt, ts);
      requestAnimationFrame(this.loop.bind(this));
    }

    // ===== ç¹ªåœ– =====
    draw(dt, now) {
      // 1. æ¸…ç©ºèƒŒæ™¯
      ctx.fillStyle = "#fffbfd"; // ç•«å¸ƒèƒŒæ™¯è‰²
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // 2. ç•«æ¥µæ·¡çš„æ ¼ç·š (ç²‰è‰²é€æ˜)
      ctx.strokeStyle = "rgba(255, 192, 203, 0.25)"; // æ¥µæ·¡ç²‰è‰²
      ctx.lineWidth = 1;
      ctx.beginPath();
      for (let x=0; x<=this.cols; x++) { ctx.moveTo(x*this.gridSize, 0); ctx.lineTo(x*this.gridSize, canvas.height); }
      for (let y=0; y<=this.rows; y++) { ctx.moveTo(0, y*this.gridSize); ctx.lineTo(canvas.width, y*this.gridSize); }
      ctx.stroke();

      // 3. ç•«é£Ÿç‰©
      const f = this.food.current;
      if (f) {
          const cx = f.pos.x * this.gridSize + this.gridSize/2;
          const cy = f.pos.y * this.gridSize + this.gridSize/2;
          const scale = this.food.popScale(now);
          ctx.save();
          ctx.translate(cx, cy);
          ctx.scale(scale, scale);
          ctx.font = `${this.gridSize * 0.85}px sans-serif`;
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText(f.emoji, 0, 2);
          ctx.restore();
      }

      // 4. ç•«è›‡ (ç´”ç™½è‰² + é™°å½±)
      const gs = this.gridSize;
      const body = this.snake.body;
      
      while(this.renderBody.length < body.length) this.renderBody.push({...body[body.length-1]});
      while(this.renderBody.length > body.length) this.renderBody.pop();

      const lerpSpeed = 15 * dt;
      for(let i=0; i<body.length; i++) {
          this.renderBody[i].x += (body[i].x - this.renderBody[i].x) * lerpSpeed;
          this.renderBody[i].y += (body[i].y - this.renderBody[i].y) * lerpSpeed;
      }

      if (this.renderBody.length > 0) {
          ctx.lineCap = "round";
          ctx.lineJoin = "round";
          
          // è›‡çš„æœ¬é«” - ç™½è‰²
          ctx.lineWidth = gs * 0.85;
          ctx.strokeStyle = "#ffffff"; 
          
          // é—œéµï¼šç”¨é™°å½±è®“ç™½è›‡åœ¨ç™½åº•ä¸Šé¡¯ç¾
          ctx.shadowColor = "rgba(180, 100, 110, 0.2)"; // æŸ”å’Œçš„ç´…æ£•è‰²é™°å½±
          ctx.shadowBlur = 10;
          ctx.shadowOffsetY = 4;

          ctx.beginPath();
          const headVis = this.renderBody[0];
          ctx.moveTo(headVis.x * gs + gs/2, headVis.y * gs + gs/2);
          for(let i=1; i<this.renderBody.length; i++) {
              ctx.lineTo(this.renderBody[i].x * gs + gs/2, this.renderBody[i].y * gs + gs/2);
          }
          ctx.stroke();
          
          // ç•«é ­éƒ¨åœ“å½¢ (ç‚ºäº†è“‹ä½ç·šæ¢ç«¯é»)
          ctx.shadowBlur = 0; // é—œé–‰é™°å½±é¿å…ç–ŠåŠ å¤ªé‡
          ctx.shadowOffsetY = 0;
          ctx.fillStyle = "#ffffff";
          const hx = headVis.x * gs + gs/2;
          const hy = headVis.y * gs + gs/2;
          ctx.beginPath();
          ctx.arc(hx, hy, gs * 0.42, 0, Math.PI*2);
          ctx.fill();

          // ç•«çœ¼ç› (æ·±æ£•è‰²)
          if (!this.isBlinking) {
            ctx.fillStyle = "#704848"; // å¯å¯è‰²çœ¼ç›
            const dir = this.snake.dir; 
            const lookX = dir.x * 2.5;
            const lookY = dir.y * 2.5;

            ctx.beginPath();
            ctx.arc(hx - 3 + lookX, hy - 2 + lookY, 2.2, 0, Math.PI*2); 
            ctx.arc(hx + 3 + lookX, hy - 2 + lookY, 2.2, 0, Math.PI*2); 
            ctx.fill();
            
            // ç•«è…®ç´… (å¯æ„›åŠ åˆ†)
            ctx.fillStyle = "rgba(255, 182, 193, 0.6)";
            ctx.beginPath();
            ctx.arc(hx - 5 + lookX, hy + 3 + lookY, 2.5, 0, Math.PI*2);
            ctx.arc(hx + 5 + lookX, hy + 3 + lookY, 2.5, 0, Math.PI*2);
            ctx.fill();

          } else {
             // çœ¨çœ¼ç·šæ¢
             ctx.strokeStyle = "#704848";
             ctx.lineWidth = 1.5;
             ctx.beginPath();
             ctx.moveTo(hx - 5, hy - 1); ctx.lineTo(hx - 1, hy - 1);
             ctx.moveTo(hx + 1, hy - 1); ctx.lineTo(hx + 5, hy - 1);
             ctx.stroke();
          }
      }

      // 5. ç‰¹æ•ˆç²’å­
      this.effects.draw(ctx);

      // 6. UI æ–‡å­—
      if (this.state !== "running") {
          ctx.fillStyle = "rgba(255, 255, 255, 0.5)";
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          
          ctx.fillStyle = "#db7093";
          ctx.textAlign = "center";
          ctx.font = "bold 26px sans-serif";
          
          let title = "é»æ“Šç•«é¢é–‹å§‹";
          let sub = "æ»‘å‹•æˆ–éµç›¤æ§åˆ¶";
          if (this.state === "gameover") { title = "éŠæˆ²çµæŸ"; sub = `å¾—åˆ†: ${this.score}`; }
          if (this.state === "paused") { title = "æš«åœ"; sub = "æŒ‰ç©ºç™½éµç¹¼çºŒ"; }

          ctx.fillText(title, canvas.width/2, canvas.height/2 - 10);
          ctx.font = "16px sans-serif";
          ctx.fillStyle = "#a88888";
          ctx.fillText(sub, canvas.width/2, canvas.height/2 + 25);
      }
    }
  }

  new Game();
})();
</script>
</body>
</html>
